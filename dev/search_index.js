var documenterSearchIndex = {"docs":
[{"location":"#ArrayLayouts.jl","page":"ArrayLayouts.jl","title":"ArrayLayouts.jl","text":"","category":"section"},{"location":"","page":"ArrayLayouts.jl","title":"ArrayLayouts.jl","text":"Documentation for ArrayLayouts.jl","category":"page"},{"location":"#ArrayLayouts.AbstractStridedLayout","page":"ArrayLayouts.jl","title":"ArrayLayouts.AbstractStridedLayout","text":"AbstractStridedLayout\n\nis an abstract type whose subtypes are returned by MemoryLayout(A) if an array A has storage laid out at regular offsets in memory, and which can therefore be passed to external C and Fortran functions expecting this memory layout.\n\nJulia's internal linear algebra machinery will automatically (and invisibly) dispatch to BLAS and LAPACK routines if the memory layout is BLAS compatible and the element type is a Float32, Float64, ComplexF32, or ComplexF64. In this case, one must implement the strided array interface, which requires overrides of strides(A::MyMatrix) and unknown_convert(::Type{Ptr{T}}, A::MyMatrix).\n\nThe complete list of more specialised types is as follows:\n\njulia> using ArrayLayouts, AbstractTrees\n\njulia> AbstractTrees.children(x::Type) = subtypes(x)\n\njulia> print_tree(AbstractStridedLayout)\nAbstractStridedLayout\n├─ AbstractDecreasingStrides\n│  └─ AbstractRowMajor\n│     ├─ DenseRowMajor\n│     └─ RowMajor\n├─ AbstractIncreasingStrides\n│  ├─ AbstractColumnMajor\n│  │  ├─ ColumnMajor\n│  │  └─ DenseColumnMajor\n│  ├─ DecreasingStrides\n│  └─ IncreasingStrides\n├─ StridedLayout\n└─ UnitStride\n\njulia> Base.show_supertypes(AbstractStridedLayout)\nAbstractStridedLayout <: MemoryLayout <: Any\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.ColumnMajor","page":"ArrayLayouts.jl","title":"ArrayLayouts.ColumnMajor","text":"ColumnMajor()\n\nis returned by MemoryLayout(A) if an array A has storage in memory as a column major array, so that stride(A,1) == 1 and stride(A,i) ≥ size(A,i-1) * stride(A,i-1) for 2 ≤ i ≤ ndims(A).\n\nArrays with ColumnMajor memory layout must conform to the DenseArray interface.\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.ConjPtr","page":"ArrayLayouts.jl","title":"ArrayLayouts.ConjPtr","text":"ConjPtr{T}\n\nA memory address referring to complex conjugated data of type T. However, there is no guarantee that the memory is actually valid, or that it actually represents the complex conjugate of data of the specified type.\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.DecreasingStrides","page":"ArrayLayouts.jl","title":"ArrayLayouts.DecreasingStrides","text":"DecreasingStrides()\n\nis returned by MemoryLayout(A) if an array A has storage in memory as a strided array with decreasing strides, so that stride(A,ndims(A)) ≥ 1 and stride(A,i) ≥ size(A,i+1) * stride(A,i+1)for1 ≤ i ≤ ndims(A)-1`.\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.DenseColumnMajor","page":"ArrayLayouts.jl","title":"ArrayLayouts.DenseColumnMajor","text":"DenseColumnMajor()\n\nis returned by MemoryLayout(A) if an array A has storage in memory equivalent to an Array, so that stride(A,1) == 1 and stride(A,i) ≡ size(A,i-1) * stride(A,i-1) for 2 ≤ i ≤ ndims(A). In particular, if A is a matrix then strides(A) ==(1, size(A,1))`.\n\nArrays with DenseColumnMajor memory layout must conform to the DenseArray interface.\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.DenseRowMajor","page":"ArrayLayouts.jl","title":"ArrayLayouts.DenseRowMajor","text":"DenseRowMajor()\n\nis returned by MemoryLayout(A) if an array A has storage in memory as a row major array with dense entries, so that stride(A,ndims(A)) == 1 and stride(A,i) ≡ size(A,i+1) * stride(A,i+1) for 1 ≤ i ≤ ndims(A)-1. In particular, if A is a matrix then strides(A) ==(size(A,2), 1)`.\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.Dot","page":"ArrayLayouts.jl","title":"ArrayLayouts.Dot","text":"Dot(A, B)\n\nis a lazy version of dot(A, B), designed to support materializing based on MemoryLayout.\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.Dotu","page":"ArrayLayouts.jl","title":"ArrayLayouts.Dotu","text":"Dotu(A, B)\n\nis a lazy version of BLAS.dotu(A, B), designed to support materializing based on MemoryLayout.\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.DualLayout","page":"ArrayLayouts.jl","title":"ArrayLayouts.DualLayout","text":"DualLayout{ML<:MemoryLayout}()\n\nrepresents a row-vector that should behave like a dual-vector, that is multiplication times a column-vector returns a scalar.\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.HermitianLayout","page":"ArrayLayouts.jl","title":"ArrayLayouts.HermitianLayout","text":"HermitianLayout(layout, uplo)\n\nis returned by MemoryLayout(A) if a matrix A has storage in memory as a hermitianized version of layout, where the entries used are dictated by the uplo, which can be 'U' or L'.\n\nA matrix that has memory layout HermitianLayout(layout, uplo) must overrided hermitiandata(A) to return a matrix B such that MemoryLayout(B) == layout and A[k,j] == B[k,j] for j ≥ k if uplo == 'U' (j ≤ k if uplo == 'L') and A[k,j] == conj(B[j,k]) for j < k if uplo == 'U' (j > k if uplo == 'L').\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.IncreasingStrides","page":"ArrayLayouts.jl","title":"ArrayLayouts.IncreasingStrides","text":"IncreasingStrides()\n\nis returned by MemoryLayout(A) if an array A has storage in memory as a strided array with  increasing strides, so that stride(A,1) ≥ 1 and stride(A,i) ≥ size(A,i-1) * stride(A,i-1) for 2 ≤ i ≤ ndims(A).\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.LULayout","page":"ArrayLayouts.jl","title":"ArrayLayouts.LULayout","text":"LULayout{SLAY}()\n\nrepresents a Packed QR factorization whose factors are stored with layout SLAY and τ stored with layout TLAY\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.LowerTriangularLayout","page":"ArrayLayouts.jl","title":"ArrayLayouts.LowerTriangularLayout","text":"LowerTriangularLayout(layout)\n\nis returned by MemoryLayout(A) if a matrix A has storage in memory equivalent to a LowerTriangular(B) where B satisfies MemoryLayout(B) == layout.\n\nA matrix that has memory layout LowerTriangularLayout(layout) must overrided triangulardata(A) to return a matrix B such that MemoryLayout(B) == layout and A[k,j] ≡ zero(eltype(A)) for j > k and A[k,j] ≡ B[k,j] for j ≤ k.\n\nMoreover, transpose(A) and adjoint(A) must return a matrix that has memory layout UpperTriangularLayout.\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.MemoryLayout-Tuple{Any}","page":"ArrayLayouts.jl","title":"ArrayLayouts.MemoryLayout","text":"MemoryLayout(A)\n\nspecifies the layout in memory for an array A. When you define a new AbstractArray type, you can choose to override MemoryLayout to indicate how an array is stored in memory. For example, if your matrix is column major with stride(A,2) == size(A,1), then override as follows:\n\nMemoryLayout(::MyMatrix) = DenseColumnMajor()\n\nThe default is UnknownLayout() to indicate that the layout in memory is unknown.\n\nJulia's internal linear algebra machinery will automatically (and invisibly) dispatch to BLAS and LAPACK routines if the memory layout is compatible.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayLayouts.QRCompactWYLayout","page":"ArrayLayouts.jl","title":"ArrayLayouts.QRCompactWYLayout","text":"QRCompactWYLayout{SLAY,TLAY}()\n\nrepresents a Compact-WY QR factorization whose factors are stored with layout SLAY and τ stored with layout TLAY\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.QRPackedLayout","page":"ArrayLayouts.jl","title":"ArrayLayouts.QRPackedLayout","text":"QRPackedLayout{SLAY,TLAY}()\n\nrepresents a Packed QR factorization whose factors are stored with layout SLAY and τ stored with layout TLAY\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.RangeCumsum","page":"ArrayLayouts.jl","title":"ArrayLayouts.RangeCumsum","text":"RangeCumsum(range)\n\nrepresents the cumsum of a AbstractRange.\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.RowMajor","page":"ArrayLayouts.jl","title":"ArrayLayouts.RowMajor","text":"RowMajor()\n\nis returned by MemoryLayout(A) if an array A has storage in memory as a row major array, so that stride(A,ndims(A)) == 1 and stride(A,i) ≥ size(A,i+1) * stride(A,i+1)for1 ≤ i ≤ ndims(A)-1`.\n\nIf A is a matrix  with RowMajor memory layout, then transpose(A) should return a matrix whose layout is ColumnMajor.\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.ScalarLayout","page":"ArrayLayouts.jl","title":"ArrayLayouts.ScalarLayout","text":"ScalarLayout()\n\nis returned by MemoryLayout(A) if A is a scalar, which does not live in memory\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.StridedLayout","page":"ArrayLayouts.jl","title":"ArrayLayouts.StridedLayout","text":"StridedLayout()\n\nis returned by MemoryLayout(A) if an array A has storage laid out at regular offsets in memory. Arrays with StridedLayout must conform to the DenseArray interface.\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.SymmetricLayout","page":"ArrayLayouts.jl","title":"ArrayLayouts.SymmetricLayout","text":"SymmetricLayout{layout}()\n\nis returned by MemoryLayout(A) if a matrix A has storage in memory as a symmetrized version of layout, where the entries used are dictated by the uplo, which can be 'U' or L'.\n\nA matrix that has memory layout SymmetricLayout(layout, uplo) must overrided symmetricdata(A) to return a matrix B such that MemoryLayout(B) == layout and A[k,j] == B[k,j] for j ≥ k if uplo == 'U' (j ≤ k if uplo == 'L') and A[k,j] == B[j,k] for j < k if uplo == 'U' (j > k if uplo == 'L').\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.UnitLowerTriangularLayout","page":"ArrayLayouts.jl","title":"ArrayLayouts.UnitLowerTriangularLayout","text":"UnitLowerTriangularLayout(ML::MemoryLayout)\n\nis returned by MemoryLayout(A) if a matrix A has storage in memory equivalent to a UnitLowerTriangular(B) where B satisfies MemoryLayout(B) == layout.\n\nA matrix that has memory layout UnitLowerTriangularLayout(layout) must overrided triangulardata(A) to return a matrix B such that MemoryLayout(B) == layout and A[k,j] ≡ zero(eltype(A)) for j > k, A[k,j] ≡ one(eltype(A)) for j == k, A[k,j] ≡ B[k,j] for j < k.\n\nMoreover, transpose(A) and adjoint(A) must return a matrix that has memory layout UnitUpperTriangularLayout.\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.UnitStride","page":"ArrayLayouts.jl","title":"ArrayLayouts.UnitStride","text":"UnitStride{D}()\n\nis returned by MemoryLayout(A) for arrays of ndims(A) >= 3 which have stride(A,D) == 1.\n\nUnitStride{1} is weaker than ColumnMajor in that it does not demand that the other strides are increasing, hence it is not a subtype of AbstractIncreasingStrides. To ensure that stride(A,1) == 1, you may dispatch on Union{UnitStride{1}, AbstractColumnMajor} to allow for both options. (With complex numbers, you may also need their ConjLayout versions.)\n\nLikewise, both UnitStride{ndims(A)} and AbstractRowMajor have stride(A, ndims(A)) == 1.\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.UnitUpperTriangularLayout","page":"ArrayLayouts.jl","title":"ArrayLayouts.UnitUpperTriangularLayout","text":"UnitUpperTriangularLayout(ML::MemoryLayout)\n\nis returned by MemoryLayout(A) if a matrix A has storage in memory equivalent to a UpperTriangularLayout(B) where B satisfies MemoryLayout(B) == ML.\n\nA matrix that has memory layout UnitUpperTriangularLayout(layout) must overrided triangulardata(A) to return a matrix B such that MemoryLayout(B) == layout and A[k,j] ≡ B[k,j] for j > k, A[k,j] ≡ one(eltype(A)) for j == k, A[k,j] ≡ zero(eltype(A)) for j < k.\n\nMoreover, transpose(A) and adjoint(A) must return a matrix that has memory layout UnitLowerTriangularLayout.\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.UnknownLayout","page":"ArrayLayouts.jl","title":"ArrayLayouts.UnknownLayout","text":"UnknownLayout()\n\nis returned by MemoryLayout(A) if it is unknown how the entries of an array A are stored in memory.\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.UpperTriangularLayout","page":"ArrayLayouts.jl","title":"ArrayLayouts.UpperTriangularLayout","text":"UpperTriangularLayout(ML::MemoryLayout)\n\nis returned by MemoryLayout(A) if a matrix A has storage in memory equivalent to a UpperTriangularLayout(B) where B satisfies MemoryLayout(B) == ML.\n\nA matrix that has memory layout UpperTriangularLayout(layout) must overrided triangulardata(A) to return a matrix B such that MemoryLayout(B) == layout and A[k,j] ≡ B[k,j] for j ≥ k and A[k,j] ≡ zero(eltype(A)) for j < k.\n\nMoreover, transpose(A) and adjoint(A) must return a matrix that has memory layout LowerTriangularLayout.\n\n\n\n\n\n","category":"type"},{"location":"#ArrayLayouts.colsupport-Tuple{Any, Any}","page":"ArrayLayouts.jl","title":"ArrayLayouts.colsupport","text":"colsupport(A, j)\n\nReturn an iterator containing the row indices of the possible non-zero entries in the j-th column of A.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayLayouts.colsupport-Tuple{Any}","page":"ArrayLayouts.jl","title":"ArrayLayouts.colsupport","text":"colsupport(A)\n\nReturn an iterator containing the row indices of the possible non-zero entries in A.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayLayouts.indextype-Tuple{Any}","page":"ArrayLayouts.jl","title":"ArrayLayouts.indextype","text":"indextype(A)\n\ngives the expected index type for an array, or array-like object. For example, if it is vector-like it will return Tuple{Int}, or if it is matrix-like it will return Tuple{Int,Int}. Other types may have non-integer based indexing.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayLayouts.mulreduce-Tuple{ArrayLayouts.Mul}","page":"ArrayLayouts.jl","title":"ArrayLayouts.mulreduce","text":"mulreduce(M::Mul)\n\nreturns a lower level lazy multiplication object such as MulAdd, Lmul or Rmul. The Default is MulAdd. Note that the lowered type must overload copyto! and copy.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayLayouts.rowsupport-Tuple{Any, Any}","page":"ArrayLayouts.jl","title":"ArrayLayouts.rowsupport","text":"rowsupport(A, k)\n\nReturn an iterator containing the column indices of the possible non-zero entries in the k-th row of A.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayLayouts.rowsupport-Tuple{Any}","page":"ArrayLayouts.jl","title":"ArrayLayouts.rowsupport","text":"rowsupport(A)\n\nReturn an iterator containing the column indices of the possible non-zero entries in A.\n\n\n\n\n\n","category":"method"}]
}
