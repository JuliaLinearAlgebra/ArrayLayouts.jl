<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ArrayLayouts.jl · ArrayLayouts</title><meta name="title" content="ArrayLayouts.jl · ArrayLayouts"/><meta property="og:title" content="ArrayLayouts.jl · ArrayLayouts"/><meta property="twitter:title" content="ArrayLayouts.jl · ArrayLayouts"/><meta name="description" content="Documentation for ArrayLayouts."/><meta property="og:description" content="Documentation for ArrayLayouts."/><meta property="twitter:description" content="Documentation for ArrayLayouts."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ArrayLayouts</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>ArrayLayouts.jl</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>ArrayLayouts.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ArrayLayouts.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ArrayLayouts.jl"><a class="docs-heading-anchor" href="#ArrayLayouts.jl">ArrayLayouts.jl</a><a id="ArrayLayouts.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ArrayLayouts.jl" title="Permalink"></a></h1><p>Documentation for ArrayLayouts.jl</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.AbstractStridedLayout" href="#ArrayLayouts.AbstractStridedLayout"><code>ArrayLayouts.AbstractStridedLayout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractStridedLayout</code></pre><p>is an abstract type whose subtypes are returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage laid out at regular offsets in memory, and which can therefore be passed to external C and Fortran functions expecting this memory layout.</p><p>Julia&#39;s internal linear algebra machinery will automatically (and invisibly) dispatch to BLAS and LAPACK routines if the memory layout is BLAS compatible and the element type is a <code>Float32</code>, <code>Float64</code>, <code>ComplexF32</code>, or <code>ComplexF64</code>. In this case, one must implement the strided array interface, which requires overrides of <code>strides(A::MyMatrix)</code> and <code>unknown_convert(::Type{Ptr{T}}, A::MyMatrix)</code>.</p><p>The complete list of more specialised types is as follows:</p><pre><code class="nohighlight hljs">julia&gt; using ArrayLayouts, AbstractTrees

julia&gt; AbstractTrees.children(x::Type) = subtypes(x)

julia&gt; print_tree(AbstractStridedLayout)
AbstractStridedLayout
├─ AbstractDecreasingStrides
│  └─ AbstractRowMajor
│     ├─ DenseRowMajor
│     └─ RowMajor
├─ AbstractIncreasingStrides
│  ├─ AbstractColumnMajor
│  │  ├─ ColumnMajor
│  │  └─ DenseColumnMajor
│  ├─ DecreasingStrides
│  └─ IncreasingStrides
├─ StridedLayout
└─ UnitStride

julia&gt; Base.show_supertypes(AbstractStridedLayout)
AbstractStridedLayout &lt;: MemoryLayout &lt;: Any</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/memorylayout.jl#L33-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.ColumnMajor" href="#ArrayLayouts.ColumnMajor"><code>ArrayLayouts.ColumnMajor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ColumnMajor()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory as a column major array, so that <code>stride(A,1) == 1</code> and <code>stride(A,i) ≥ size(A,i-1) * stride(A,i-1)</code> for <code>2 ≤ i ≤ ndims(A)</code>.</p><p>Arrays with <code>ColumnMajor</code> memory layout must conform to the <code>DenseArray</code> interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/memorylayout.jl#L86-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.ConjPtr" href="#ArrayLayouts.ConjPtr"><code>ArrayLayouts.ConjPtr</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConjPtr{T}</code></pre><p>A memory address referring to complex conjugated data of type T. However, there is no guarantee that the memory is actually valid, or that it actually represents the complex conjugate of data of the specified type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/ArrayLayouts.jl#L87-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.DecreasingStrides" href="#ArrayLayouts.DecreasingStrides"><code>ArrayLayouts.DecreasingStrides</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DecreasingStrides()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory as a strided array with decreasing strides, so that <code>stride(A,ndims(A)) ≥ 1</code> and stride(A,i) ≥ size(A,i+1) * stride(A,i+1)<code>for</code>1 ≤ i ≤ ndims(A)-1`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/memorylayout.jl#L128-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.DenseColumnMajor" href="#ArrayLayouts.DenseColumnMajor"><code>ArrayLayouts.DenseColumnMajor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DenseColumnMajor()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory equivalent to an <code>Array</code>, so that <code>stride(A,1) == 1</code> and <code>stride(A,i) ≡ size(A,i-1) * stride(A,i-1)</code> for <code>2 ≤ i ≤ ndims(A)</code>. In particular, if <code>A</code> is a matrix then <code>strides(A) ==</code>(1, size(A,1))`.</p><p>Arrays with <code>DenseColumnMajor</code> memory layout must conform to the <code>DenseArray</code> interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/memorylayout.jl#L74-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.DenseRowMajor" href="#ArrayLayouts.DenseRowMajor"><code>ArrayLayouts.DenseRowMajor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DenseRowMajor()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory as a row major array with dense entries, so that <code>stride(A,ndims(A)) == 1</code> and <code>stride(A,i) ≡ size(A,i+1) * stride(A,i+1)</code> for <code>1 ≤ i ≤ ndims(A)-1</code>. In particular, if <code>A</code> is a matrix then <code>strides(A) ==</code>(size(A,2), 1)`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/memorylayout.jl#L106-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.Dot" href="#ArrayLayouts.Dot"><code>ArrayLayouts.Dot</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Dot(A, B)</code></pre><p>is a lazy version of <code>dot(A, B)</code>, designed to support materializing based on <code>MemoryLayout</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/mul.jl#L352-L357">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.Dotu" href="#ArrayLayouts.Dotu"><code>ArrayLayouts.Dotu</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Dotu(A, B)</code></pre><p>is a lazy version of <code>BLAS.dotu(A, B)</code>, designed to support materializing based on <code>MemoryLayout</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/mul.jl#L363-L368">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.DualLayout" href="#ArrayLayouts.DualLayout"><code>ArrayLayouts.DualLayout</code></a> — <span class="docstring-category">Type</span></header><section><div><p>DualLayout{ML&lt;:MemoryLayout}()</p><p>represents a row-vector that should behave like a dual-vector, that is multiplication times a column-vector returns a scalar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/memorylayout.jl#L274-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.HermitianLayout" href="#ArrayLayouts.HermitianLayout"><code>ArrayLayouts.HermitianLayout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HermitianLayout(layout, uplo)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory as a hermitianized version of <code>layout</code>, where the entries used are dictated by the <code>uplo</code>, which can be <code>&#39;U&#39;</code> or <code>L&#39;</code>.</p><p>A matrix that has memory layout <code>HermitianLayout(layout, uplo)</code> must overrided <code>hermitiandata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] == B[k,j]</code> for <code>j ≥ k</code> if <code>uplo == &#39;U&#39;</code> (<code>j ≤ k</code> if <code>uplo == &#39;L&#39;</code>) and <code>A[k,j] == conj(B[j,k])</code> for <code>j &lt; k</code> if <code>uplo == &#39;U&#39;</code> (<code>j &gt; k</code> if <code>uplo == &#39;L&#39;</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/memorylayout.jl#L382-L394">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.IncreasingStrides" href="#ArrayLayouts.IncreasingStrides"><code>ArrayLayouts.IncreasingStrides</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IncreasingStrides()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory as a strided array with  increasing strides, so that <code>stride(A,1) ≥ 1</code> and <code>stride(A,i) ≥ size(A,i-1) * stride(A,i-1)</code> for <code>2 ≤ i ≤ ndims(A)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/memorylayout.jl#L97-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.LULayout" href="#ArrayLayouts.LULayout"><code>ArrayLayouts.LULayout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LULayout{SLAY}()</code></pre><p>represents a Packed QR factorization whose factors are stored with layout SLAY and τ stored with layout TLAY</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/factorizations.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.LowerTriangularLayout" href="#ArrayLayouts.LowerTriangularLayout"><code>ArrayLayouts.LowerTriangularLayout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LowerTriangularLayout(layout)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory equivalent to a <code>LowerTriangular(B)</code> where <code>B</code> satisfies <code>MemoryLayout(B) == layout</code>.</p><p>A matrix that has memory layout <code>LowerTriangularLayout(layout)</code> must overrided <code>triangulardata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] ≡ zero(eltype(A))</code> for <code>j &gt; k</code> and <code>A[k,j] ≡ B[k,j]</code> for <code>j ≤ k</code>.</p><p>Moreover, <code>transpose(A)</code> and <code>adjoint(A)</code> must return a matrix that has memory layout <code>UpperTriangularLayout</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/memorylayout.jl#L433-L446">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.MemoryLayout-Tuple{Any}" href="#ArrayLayouts.MemoryLayout-Tuple{Any}"><code>ArrayLayouts.MemoryLayout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MemoryLayout(A)</code></pre><p>specifies the layout in memory for an array <code>A</code>. When you define a new <code>AbstractArray</code> type, you can choose to override <code>MemoryLayout</code> to indicate how an array is stored in memory. For example, if your matrix is column major with <code>stride(A,2) == size(A,1)</code>, then override as follows:</p><pre><code class="nohighlight hljs">MemoryLayout(::MyMatrix) = DenseColumnMajor()</code></pre><p>The default is <code>UnknownLayout()</code> to indicate that the layout in memory is unknown.</p><p>Julia&#39;s internal linear algebra machinery will automatically (and invisibly) dispatch to BLAS and LAPACK routines if the memory layout is compatible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/memorylayout.jl#L152-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.QRCompactWYLayout" href="#ArrayLayouts.QRCompactWYLayout"><code>ArrayLayouts.QRCompactWYLayout</code></a> — <span class="docstring-category">Type</span></header><section><div><p>QRCompactWYLayout{SLAY,TLAY}()</p><p>represents a Compact-WY QR factorization whose factors are stored with layout SLAY and τ stored with layout TLAY</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/factorizations.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.QRPackedLayout" href="#ArrayLayouts.QRPackedLayout"><code>ArrayLayouts.QRPackedLayout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QRPackedLayout{SLAY,TLAY}()</code></pre><p>represents a Packed QR factorization whose factors are stored with layout SLAY and τ stored with layout TLAY</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/factorizations.jl#L10-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.RangeCumsum" href="#ArrayLayouts.RangeCumsum"><code>ArrayLayouts.RangeCumsum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RangeCumsum(range)</code></pre><p>represents the cumsum of a <code>AbstractRange</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/cumsum.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.RowMajor" href="#ArrayLayouts.RowMajor"><code>ArrayLayouts.RowMajor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RowMajor()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory as a row major array, so that <code>stride(A,ndims(A)) == 1</code> and stride(A,i) ≥ size(A,i+1) * stride(A,i+1)<code>for</code>1 ≤ i ≤ ndims(A)-1`.</p><p>If <code>A</code> is a matrix  with <code>RowMajor</code> memory layout, then <code>transpose(A)</code> should return a matrix whose layout is <code>ColumnMajor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/memorylayout.jl#L116-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.ScalarLayout" href="#ArrayLayouts.ScalarLayout"><code>ArrayLayouts.ScalarLayout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScalarLayout()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if A is a scalar, which does not live in memory</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/memorylayout.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.StridedLayout" href="#ArrayLayouts.StridedLayout"><code>ArrayLayouts.StridedLayout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StridedLayout()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage laid out at regular offsets in memory. <code>Array</code>s with <code>StridedLayout</code> must conform to the <code>DenseArray</code> interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/memorylayout.jl#L137-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.SymmetricLayout" href="#ArrayLayouts.SymmetricLayout"><code>ArrayLayouts.SymmetricLayout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SymmetricLayout{layout}()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory as a symmetrized version of <code>layout</code>, where the entries used are dictated by the <code>uplo</code>, which can be <code>&#39;U&#39;</code> or <code>L&#39;</code>.</p><p>A matrix that has memory layout <code>SymmetricLayout(layout, uplo)</code> must overrided <code>symmetricdata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] == B[k,j]</code> for <code>j ≥ k</code> if <code>uplo == &#39;U&#39;</code> (<code>j ≤ k</code> if <code>uplo == &#39;L&#39;</code>) and <code>A[k,j] == B[j,k]</code> for <code>j &lt; k</code> if <code>uplo == &#39;U&#39;</code> (<code>j &gt; k</code> if <code>uplo == &#39;L&#39;</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/memorylayout.jl#L367-L379">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.UnitLowerTriangularLayout" href="#ArrayLayouts.UnitLowerTriangularLayout"><code>ArrayLayouts.UnitLowerTriangularLayout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UnitLowerTriangularLayout(ML::MemoryLayout)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory equivalent to a <code>UnitLowerTriangular(B)</code> where <code>B</code> satisfies <code>MemoryLayout(B) == layout</code>.</p><p>A matrix that has memory layout <code>UnitLowerTriangularLayout(layout)</code> must overrided <code>triangulardata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] ≡ zero(eltype(A))</code> for <code>j &gt; k</code>, <code>A[k,j] ≡ one(eltype(A))</code> for <code>j == k</code>, <code>A[k,j] ≡ B[k,j]</code> for <code>j &lt; k</code>.</p><p>Moreover, <code>transpose(A)</code> and <code>adjoint(A)</code> must return a matrix that has memory layout <code>UnitUpperTriangularLayout</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/memorylayout.jl#L449-L463">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.UnitStride" href="#ArrayLayouts.UnitStride"><code>ArrayLayouts.UnitStride</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UnitStride{D}()</code></pre><p>is returned by <code>MemoryLayout(A)</code> for arrays of <code>ndims(A) &gt;= 3</code> which have <code>stride(A,D) == 1</code>.</p><p><code>UnitStride{1}</code> is weaker than <code>ColumnMajor</code> in that it does not demand that the other strides are increasing, hence it is not a subtype of <code>AbstractIncreasingStrides</code>. To ensure that <code>stride(A,1) == 1</code>, you may dispatch on <code>Union{UnitStride{1}, AbstractColumnMajor}</code> to allow for both options. (With complex numbers, you may also need their <code>ConjLayout</code> versions.)</p><p>Likewise, both <code>UnitStride{ndims(A)}</code> and <code>AbstractRowMajor</code> have <code>stride(A, ndims(A)) == 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/memorylayout.jl#L314-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.UnitUpperTriangularLayout" href="#ArrayLayouts.UnitUpperTriangularLayout"><code>ArrayLayouts.UnitUpperTriangularLayout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UnitUpperTriangularLayout(ML::MemoryLayout)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory equivalent to a <code>UpperTriangularLayout(B)</code> where <code>B</code> satisfies <code>MemoryLayout(B) == ML</code>.</p><p>A matrix that has memory layout <code>UnitUpperTriangularLayout(layout)</code> must overrided <code>triangulardata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] ≡ B[k,j]</code> for <code>j &gt; k</code>, <code>A[k,j] ≡ one(eltype(A))</code> for <code>j == k</code>, <code>A[k,j] ≡ zero(eltype(A))</code> for <code>j &lt; k</code>.</p><p>Moreover, <code>transpose(A)</code> and <code>adjoint(A)</code> must return a matrix that has memory layout <code>UnitLowerTriangularLayout</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/memorylayout.jl#L482-L496">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.UnknownLayout" href="#ArrayLayouts.UnknownLayout"><code>ArrayLayouts.UnknownLayout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UnknownLayout()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if it is unknown how the entries of an array <code>A</code> are stored in memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/memorylayout.jl#L25-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.UpperTriangularLayout" href="#ArrayLayouts.UpperTriangularLayout"><code>ArrayLayouts.UpperTriangularLayout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UpperTriangularLayout(ML::MemoryLayout)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory equivalent to a <code>UpperTriangularLayout(B)</code> where <code>B</code> satisfies <code>MemoryLayout(B) == ML</code>.</p><p>A matrix that has memory layout <code>UpperTriangularLayout(layout)</code> must overrided <code>triangulardata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] ≡ B[k,j]</code> for <code>j ≥ k</code> and <code>A[k,j] ≡ zero(eltype(A))</code> for <code>j &lt; k</code>.</p><p>Moreover, <code>transpose(A)</code> and <code>adjoint(A)</code> must return a matrix that has memory layout <code>LowerTriangularLayout</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/memorylayout.jl#L466-L479">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.colsupport-Tuple{Any, Any}" href="#ArrayLayouts.colsupport-Tuple{Any, Any}"><code>ArrayLayouts.colsupport</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">colsupport(A, j)</code></pre><p>gives an iterator containing the possible non-zero entries in the j-th column of A.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/memorylayout.jl#L652-L656">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.indextype-Tuple{Any}" href="#ArrayLayouts.indextype-Tuple{Any}"><code>ArrayLayouts.indextype</code></a> — <span class="docstring-category">Method</span></header><section><div><p>indextype(A)</p><p>gives the expected index type for an array, or array-like object. For example, if it is vector-like it will return <code>Tuple{Int}</code>, or if it is matrix-like it will return <code>Tuple{Int,Int}</code>. Other types may have non-integer based indexing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/mul.jl#L65-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.mulreduce-Tuple{ArrayLayouts.Mul}" href="#ArrayLayouts.mulreduce-Tuple{ArrayLayouts.Mul}"><code>ArrayLayouts.mulreduce</code></a> — <span class="docstring-category">Method</span></header><section><div><p>mulreduce(M::Mul)</p><p>returns a lower level lazy multiplication object such as <code>MulAdd</code>, <code>Lmul</code> or <code>Rmul</code>. The Default is <code>MulAdd</code>. Note that the lowered type must overload <code>copyto!</code> and <code>copy</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/mul.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArrayLayouts.rowsupport-Tuple{Any, Any}" href="#ArrayLayouts.rowsupport-Tuple{Any, Any}"><code>ArrayLayouts.rowsupport</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rowsupport(A, k)</code></pre><p>gives an iterator containing the possible non-zero entries in the k-th row of A.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArrayLayouts.jl/blob/44161a826044652c6cfc8d69ea4c85d43ea455ae/src/memorylayout.jl#L641-L645">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Wednesday 6 December 2023 08:25">Wednesday 6 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
